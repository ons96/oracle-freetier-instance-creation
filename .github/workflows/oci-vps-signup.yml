name: Oracle Always-Free VPS Signup

on:
  workflow_dispatch:
    inputs:
      availability_domain:
        description: 'Availability Domain'
        required: false
        default: 'AD-1,AD-2,AD-3'
        type: choice
        options:
          - AD-1
          - AD-2
          - AD-3
          - AD-1,AD-2,AD-3
      boot_volume_size:
        description: 'Boot volume size (Max 50GB for safety, default 50)'
        required: false
        default: '50'
        type: string
      instance_name:
        description: 'Instance display name'
        required: false
        default: 'github-actions-ampere-instance'
        type: string
  schedule:
    # Run every 6 hours for 24/7 continuous coverage
    # This maximizes chances of catching capacity when it becomes available
    - cron: '0 */6 * * *' # Every 6 hours at 00:00, 06:00, 12:00, 18:00 UTC

permissions:
  contents: read
  actions: write
  issues: write

jobs:
  oracle-signup:
    # Run continuously even after instance creation for daily reminders
    # This ensures you get notified if you miss the first success notification
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Verify All Required Secrets
        env:
          OCI_USER_ID: ${{ secrets.OCI_USER_ID }}
          OCI_TENANCY_ID: ${{ secrets.OCI_TENANCY_ID }}
          OCI_FINGERPRINT: ${{ secrets.OCI_FINGERPRINT }}
          OCI_PRIVATE_KEY: ${{ secrets.OCI_PRIVATE_KEY }}
          OCI_REGION: ${{ secrets.OCI_REGION }}
        run: |
          set -euo pipefail

          echo "Verifying all required secrets..."
          required=("OCI_USER_ID" "OCI_TENANCY_ID" "OCI_FINGERPRINT" "OCI_PRIVATE_KEY" "OCI_REGION")
          missing=0

          for name in "${required[@]}"; do
            if [ -z "${!name:-}" ]; then
              echo "Missing secret: ${name}"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            echo "Add missing secrets in: Settings â†’ Secrets and variables â†’ Actions"
            exit 1
          fi

          echo "All required secrets are set"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install OCI CLI
        run: |
          pip install oci-cli
          echo "OCI CLI installed for instance checking"

      - name: Create OCI directory
        run: mkdir -p ~/.oci

      - name: Setup OCI configuration
        env:
          OCI_USER_ID: ${{ secrets.OCI_USER_ID }}
          OCI_TENANCY_ID: ${{ secrets.OCI_TENANCY_ID }}
          OCI_FINGERPRINT: ${{ secrets.OCI_FINGERPRINT }}
          OCI_PRIVATE_KEY: ${{ secrets.OCI_PRIVATE_KEY }}
          OCI_REGION: ${{ secrets.OCI_REGION }}
        run: |
          set -euo pipefail

          echo "=== Creating OCI Configuration ==="
          echo "OCI_USER_ID (first 12 chars): ${OCI_USER_ID:0:12}..."
          echo "OCI_TENANCY_ID (first 12 chars): ${OCI_TENANCY_ID:0:12}..."
          echo "OCI_FINGERPRINT (first 12 chars): ${OCI_FINGERPRINT:0:12}..."
          echo "OCI_REGION: ${OCI_REGION}"
          echo "OCI_PRIVATE_KEY length: ${#OCI_PRIVATE_KEY}"

          # Write config file using printf to avoid heredoc YAML issues
          printf '[DEFAULT]\nuser=%s\nfingerprint=%s\nkey_file=%s/.oci/oci_private_key.pem\ntenancy=%s\nregion=%s\n' \
            "${OCI_USER_ID}" \
            "${OCI_FINGERPRINT}" \
            "${HOME}" \
            "${OCI_TENANCY_ID}" \
            "${OCI_REGION}" > ~/.oci/config
          
          # Debug: Show config file content (first 3 lines, redacted)
          echo "=== Config file content ==="
          head -3 ~/.oci/config || echo "Config file is empty or missing!"
          echo "=== End config ==="

          printf '%s' "$OCI_PRIVATE_KEY" > ~/.oci/oci_private_key.pem
          chmod 600 ~/.oci/oci_private_key.pem

          echo ""
          echo "=== Verifying OCI Configuration ==="
          if [ -f ~/.oci/config ]; then
            echo "Config file created"
            echo "Config content (redacted):"
            sed -E \
              -e 's/^(user=).+$/\1[REDACTED]/' \
              -e 's/^(tenancy=).+$/\1[REDACTED]/' \
              ~/.oci/config
          else
            echo "Config file NOT created"
            exit 1
          fi

      - name: Validate boot volume size
        env:
          BOOT_VOLUME_SIZE: ${{ github.event.inputs.boot_volume_size || '50' }}
        run: |
          set -euo pipefail

          boot_size="${BOOT_VOLUME_SIZE}"
          if ! [[ "$boot_size" =~ ^[0-9]+$ ]]; then
            echo "Boot volume size must be a whole number of GB. Got: '$boot_size'"
            exit 1
          fi

          if [ "$boot_size" -gt 100 ]; then
            echo "Boot volume size ${boot_size}GB exceeds 100GB safety limit"
            echo "For Always-Free safety, use 50GB unless you know your tenancy's exact free storage constraints."
            exit 1
          fi

          echo "Boot volume size valid: ${boot_size}GB"

      - name: Check for existing instance
        id: check_instance
        env:
          OCI_CONFIG: ${{ env.HOME }}/.oci/config
          OCI_USER_ID: ${{ secrets.OCI_USER_ID }}
          OCI_TENANCY_ID: ${{ secrets.OCI_TENANCY_ID }}
          OCI_FINGERPRINT: ${{ secrets.OCI_FINGERPRINT }}
          OCI_PRIVATE_KEY: ${{ secrets.OCI_PRIVATE_KEY }}
          OCI_REGION: ${{ secrets.OCI_REGION }}
        run: |
          set -euo pipefail

          # Expand $HOME in path
          OCI_CONFIG="${HOME}/.oci/config"

          echo "Checking for existing Always-Free instances..."

          # Query OCI for existing VM.Standard.A1.Flex instances
          existing_instances=$(oci compute instance list \
            --compartment-id "${OCI_TENANCY_ID}" \
            --lifecycle-state RUNNING \
            --query "data[?shape=='VM.Standard.A1.Flex'] | length(@)" \
            2>/dev/null || echo "0")

          if [ "${existing_instances:-0}" -gt 0 ]; then
            echo "instance_exists=true" >> $GITHUB_OUTPUT
            echo "Found ${existing_instances} existing VM.Standard.A1.Flex instance(s)"
            
            # Get instance details for the reminder
            oci compute instance list \
              --compartment-id "${OCI_TENANCY_ID}" \
              --lifecycle-state RUNNING \
              --query "data[?shape=='VM.Standard.A1.Flex'].{id:id, displayName:display-name, ad:availability-domain, timeCreated:time-created} | [0]" \
              > INSTANCE_CREATED 2>/dev/null || true
          else
            echo "instance_exists=false" >> $GITHUB_OUTPUT
            echo "No existing VM.Standard.A1.Flex instances found"
          fi

      - name: Create instance
        if: steps.check_instance.outputs.instance_exists != 'true'
        env:
          # Run for almost 6 hours (GitHub Actions max is 6 hours = 21600 seconds)
          # This maximizes retry time for catching capacity
          MAX_RUNTIME_SECS: 21500
          OCI_CONFIG: ${{ env.HOME }}/.oci/config
          OCI_USER_ID: ${{ secrets.OCI_USER_ID }}
          OCI_TENANCY_ID: ${{ secrets.OCI_TENANCY_ID }}
          OCI_FINGERPRINT: ${{ secrets.OCI_FINGERPRINT }}
          OCI_PRIVATE_KEY: ${{ secrets.OCI_PRIVATE_KEY }}
          OCI_REGION: ${{ secrets.OCI_REGION }}
          # Use all 3 ADs for maximum capacity checking
          OCT_FREE_AD: ${{ github.event.inputs.availability_domain || 'AD-1,AD-2,AD-3' }}
          DISPLAY_NAME: ${{ github.event.inputs.instance_name || 'github-actions-ampere-instance' }}
          OCI_COMPUTE_SHAPE: VM.Standard.A1.Flex
          BOOT_VOLUME_SIZE: ${{ github.event.inputs.boot_volume_size || '50' }}
          OPERATING_SYSTEM: Canonical Ubuntu
          OS_VERSION: '22.04'
          ASSIGN_PUBLIC_IP: 'false'
          SECOND_MICRO_INSTANCE: 'false'
          # Retry every 10 seconds (safe for Oracle API limits)
          REQUEST_WAIT_TIME_SECS: '10'
          CI: 'true'
          GITHUB_ACTIONS: 'true'
        run: |
          set -euo pipefail

          echo "Starting instance creation..."
          echo "AD: ${OCT_FREE_AD} | Boot: ${BOOT_VOLUME_SIZE}GB | Region: ${OCI_REGION}"

          # Expand $HOME in path (environment variables don't expand in GitHub Actions)
          OCI_CONFIG="${HOME}/.oci/config"

          if [ ! -f "${OCI_CONFIG}" ]; then
            echo "OCI config file not found at: ${OCI_CONFIG}"
            exit 1
          fi

          python main.py

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: instance-logs
          path: |
            INSTANCE_CREATED
            MAX_RUNTIME_REACHED
            setup_and_info.log
            launch_instance.log
            ERROR_IN_CONFIG.log
            UNHANDLED_ERROR.log
          retention-days: 30

      - name: Show results
        if: always()
        run: |
          set -euo pipefail

          echo "=== Results ==="
          if [ -f INSTANCE_CREATED ]; then
            echo "Instance created!"
            cat INSTANCE_CREATED
          elif [ -f MAX_RUNTIME_REACHED ]; then
            echo "Max runtime reached, no capacity yet"
            cat MAX_RUNTIME_REACHED
          else
            echo "Instance creation failed"
          fi

      - name: Daily reminder & instance tracking
        if: hashFiles('INSTANCE_CREATED') != ''
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const fs = require('fs');

            async function upsertRepoVariable(name, value) {
              try {
                await github.request('PATCH /repos/{owner}/{repo}/actions/variables/{name}', {
                  owner,
                  repo,
                  name,
                  value,
                });
              } catch (e) {
                if (e.status === 404) {
                  await github.request('POST /repos/{owner}/{repo}/actions/variables', {
                    owner,
                    repo,
                    name,
                    value,
                  });
                } else {
                  throw e;
                }
              }
            }

            async function getRepoVariable(name) {
              try {
                const { data } = await github.request('GET /repos/{owner}/{repo}/actions/variables/{name}', {
                  owner,
                  repo,
                  name,
                });
                return data.value;
              } catch (e) {
                if (e.status === 404) {
                  return null;
                }
                throw e;
              }
            }

            const details = fs.readFileSync('INSTANCE_CREATED', 'utf8');
            const today = new Date().toISOString().split('T')[0];
            const lastReminderDate = await getRepoVariable('LAST_REMINDER_DATE');

            // Only send reminder once per day
            if (lastReminderDate !== today) {
              console.log(`Sending daily reminder for ${today}...`);

              const issueTitle = `ðŸ“§ Daily Reminder: Oracle Instance Active (${today})`;
              const issueBody = `Your Oracle Always-Free VPS is still active and running.\n\n\`\`\`\n${details}\n\`\`\`\n\n*This is an automated daily reminder. Disable the workflow in Actions tab when you're ready to stop receiving these.*`;

              try {
                // Search for existing daily reminder issue
                const { data: issues } = await github.rest.issues.listForRepo({
                  owner,
                  repo,
                  state: 'open',
                  labels: 'daily-reminder',
                  per_page: 1,
                });

                if (issues.length > 0) {
                  // Update existing reminder issue
                  await github.rest.issues.update({
                    owner,
                    repo,
                    issue_number: issues[0].number,
                    title: issueTitle,
                    body: issueBody,
                  });
                  console.log(`Updated reminder issue #${issues[0].number}`);
                } else {
                  // Create new reminder issue with success notification
                  const { data: newIssue } = await github.rest.issues.create({
                    owner,
                    repo,
                    title: `âœ… Oracle Always-Free VPS Created + Daily Reminder (${today})`,
                    body: `ðŸŽ‰ **Instance successfully created!**\n\n\`\`\`\n${details}\n\`\`\`\n\n*This issue will be updated daily as a reminder. Disable the workflow in Actions tab when ready.*`,
                    labels: ['daily-reminder'],
                    assignees: [context.actor],
                  });
                  console.log(`Created success notification + reminder issue #${newIssue.number}`);
                }
              } catch (e) {
                console.log('Note: Could not create/update issue:', e.message);
              }

              // Update the last reminder date
              await upsertRepoVariable('LAST_REMINDER_DATE', today);
              console.log(`Updated LAST_REMINDER_DATE to ${today}`);
            } else {
              console.log(`Reminder already sent for ${today}. Skipping...`);
            }

            console.log('Note: Workflow continues running for daily reminders. Disable manually in Actions tab when ready.');
